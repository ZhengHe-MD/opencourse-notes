<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1.0, user-scalable=no">

    
      <link rel="icon" href="/opencourse-notes/favicon.png" />
    

    <title>
        
          Lecture-9-Hashing-II - 公开课笔记
        
    </title>

    <!-- Spectre.css framework -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-exp.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/spectre.css/0.5.9/spectre-icons.min.css">

    <!-- theme css & js -->
    
<link rel="stylesheet" href="/opencourse-notes/css/book.css">

    
<script src="/opencourse-notes/js/book.js"></script>


    <!-- tocbot -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.4.2/tocbot.css">
    
    <!-- katex -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">

    
<!-- Google Analytics -->
<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-172943223-3', 'auto');
ga('send', 'pageview');
</script>
<!-- End Google Analytics -->

    
<script src="https://cdnjs.cloudflare.com/ajax/libs/zooming/2.1.1/zooming.min.js"></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    const zooming = new Zooming()
    zooming.listen('.book-content img')
})
</script>

<meta name="generator" content="Hexo 5.3.0"></head>

<body>

<div class="book-container">
  <div class="book-sidebar">
    <div class="book-brand">
  <a href="/opencourse-notes/">
    <img src="/opencourse-notes/favicon.png">
    <span>公开课笔记</span>
  </a>
</div>
    <div id="menu" class="book-menu hide">
  <h1 id="算法与数据结构">算法与数据结构</h1>
<h2 id="mit-6.006">MIT 6.006</h2>
<ul>
<li><a href="/opencourse-notes/MIT-6-006/Lecture-8-Hashing-I">Lecture 8: Hashing I</a></li>
</ul>
<h2 id="mit-6.046j">MIT 6.046J</h2>
<ul>
<li><a href="/opencourse-notes/MIT-6-046J/Lecture-8-Hashing">Lecture 8: Hashing</a></li>
</ul>
<h1 id="数据库">数据库</h1>

</div>


<script src="/opencourse-notes/js/book-menu.js"></script>

  </div>

  <div class="sidebar-toggle" onclick="sidebar_toggle()" onmouseover="add_inner()" onmouseleave="remove_inner()">
  <div class="sidebar-toggle-inner"></div>
</div>

<script>
function add_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.add('show')  
}

function remove_inner() {
  let inner = document.querySelector('.sidebar-toggle-inner')
  inner.classList.remove('show')
}

function sidebar_toggle() {
    let sidebar_toggle = document.querySelector('.sidebar-toggle')
    let sidebar = document.querySelector('.book-sidebar')
    let content = document.querySelector('.off-canvas-content')
    if (sidebar_toggle.classList.contains('extend')) { // show
        sidebar_toggle.classList.remove('extend')
        sidebar.classList.remove('hide')
        content.classList.remove('extend')
    }
    else { // hide
        sidebar_toggle.classList.add('extend')
        sidebar.classList.add('hide')
        content.classList.add('extend')
    }
}
</script>

  <div class="off-canvas-content">
    <div class="columns">
      <div class="column col-10 col-lg-12">
        <div class="book-navbar">
          <!-- For Responsive Layout -->

<header class="navbar">
  <section class="navbar-section">
    <a onclick="open_sidebar()">
      <i class="icon icon-menu"></i>
    </a>
  </section>
</header>

        </div>
        <div class="book-content">
          <div class="book-post">
  <h1 id="lecture-9-hashing-ii">Lecture 9: Hashing II</h1>
<h2 id="overview">0. Overview</h2>
<ul>
<li>Table Resizing</li>
<li>Amortization</li>
<li>String Matching and Karp-Rabin</li>
<li>Rolling Hash</li>
</ul>
<h2 id="how-large-should-table-be-table-resizing">1. How large should table be? Table Resizing</h2>
<p>到目前为止，我们的讨论都建立在假设 "hash table 大小不变" 的前提下。在实践中多数情况下我们无法确定 hash table 的最终大小，且不同的 hash table 大小不同，理想情况下，我们希望无论输入怎样，都能做到 <span class="math inline">\(m = \theta(n)\)</span>。如果使用静态大小的 hash table，则可能出现以下两种情况：若 <span class="math inline">\(m\)</span> 过小，则 <span class="math inline">\(\alpha\)</span> 过大，导致 hash table 性能下降；若 <span class="math inline">\(m\)</span> 过大，则填充率低，导致空间浪费。一个自然而然的想法就是使用动态大小的 hash table：<strong>从一个小的固定 (常数) 开始，按需放缩</strong>。</p>
<h3 id="rehashing">1.1 Rehashing</h3>
<p>在扩容或缩容之后，我们需要重新计算每个元素的位置，这个过程称为 rehashing：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> oldTable:</span><br><span class="line">  newTable.insert(item)</span><br></pre></td></tr></table></figure>
<p>rehashing 的时间复杂度为 <span class="math inline">\(\theta(n+m)\)</span>，如果 <span class="math inline">\(m = \theta(n)\)</span>，则总时间复杂度为 <span class="math inline">\(\theta(n)\)</span>。</p>
<h3 id="how-fast-to-grow">1.2 How fast to grow?</h3>
<p>什么时候触发 table resizing？</p>
<ul>
<li><span class="math inline">\(m += 1\)</span>：即每次插入新的 key/item 时扩容。<span class="math inline">\(n\)</span> 次 <code>insert</code> 的时间复杂度为：<span class="math inline">\(\theta(1+2+...+n) = \theta(n^2)\)</span></li>
<li><span class="math inline">\(m\space *= 2\)</span>：在第 <span class="math inline">\(2^i\)</span> 次插入 (假设没有重复 keys) 时扩容。<span class="math inline">\(n\)</span> 次 <code>insert</code> 的时间复杂度为：<span class="math inline">\(\theta(1+2+4+8+...+n) = \theta(n)\)</span>。尽管每次扩容的时间复杂度为 <span class="math inline">\(\theta(n)\)</span>，但平均到每次插入时间复杂度为 <span class="math inline">\(\theta(1)\)</span>，即所谓 amotized cost (均摊复杂度)。</li>
</ul>
<h3 id="amortized-analysis">1.3 Amortized Analysis</h3>
<p>amorized analysis 就像按揭贷款，尽管贷款总金额高，但月供可以接受。</p>
<blockquote>
<p>当一个方法执行 <span class="math inline">\(k\)</span> 次的复杂度 <span class="math inline">\(\le k \cdot T(n)\)</span> 时，我们称该方法的 amortized cost 为 <span class="math inline">\(T(n)\)</span></p>
</blockquote>
<p>所以，根据上一节的分析，我们可以认为：插入一个新 key/item 到 hash table 中的 amortized time 为 <span class="math inline">\(\theta(1)\)</span>。</p>
<h3 id="final-time-complexity">1.4 Final Time Complexity</h3>
<p>在 SUHA 下，通过 table resizing，我们能够维持 <span class="math inline">\(m = \theta(n)\)</span>，即保证 <span class="math inline">\(\alpha = \theta(1)\)</span>，这样 search 的时间复杂度为 <span class="math inline">\(\theta(1)\)</span>。如果删除数据后不缩容，可能造成空间浪费。CLRS 建议当 <span class="math inline">\(n\)</span> 下降到 <span class="math inline">\(\frac{m}{4}\)</span> 时将容量缩小一半，推理过程类似 insert，不难想到 delete 的 amortized time 为 <span class="math inline">\(\theta(1)\)</span>。</p>
<p>综上所述：hash table 的时间复杂度分析如下表所示：</p>
<table>
<thead>
<tr class="header">
<th>Method</th>
<th>Time Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Insert(item)</td>
<td><span class="math inline">\(\theta(1)\)</span> amortized</td>
</tr>
<tr class="even">
<td>delete(item)</td>
<td><span class="math inline">\(\theta(1)\)</span> amortized</td>
</tr>
<tr class="odd">
<td>search(key)</td>
<td><span class="math inline">\(\theta(1)\)</span></td>
</tr>
</tbody>
</table>
<h2 id="string-matching">2. String Matching</h2>
<p><strong>输入两个字符串 <span class="math inline">\(s\)</span> 和 <span class="math inline">\(t\)</span>，确定 <span class="math inline">\(s\)</span> 是否是 <span class="math inline">\(t\)</span> 的子串 (如果是，请输出出现的次数和位置)</strong>。string matching 最常见的应用场景就是 unix/linux 中的 <em>grep</em> 命令。</p>
<h3 id="simple-algorithm">2.1 Simple Algorithm</h3>
<p>暴力解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ret, pos = false, -<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t) - <span class="built_in">len</span>(s)):</span><br><span class="line">  <span class="keyword">if</span> s == t[i:i+<span class="built_in">len</span>(s)]:</span><br><span class="line">    ret, pos = true, i</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> ret, pos</span><br></pre></td></tr></table></figure>
<p>时间复杂度：每次子串对比消耗 <span class="math inline">\(\theta(|s|)\)</span>，一共对比 <span class="math inline">\(|t| - |s|\)</span> 次，因此时间复杂度为：<span class="math inline">\(\theta(|s| \cdot (|t| - |s|))\)</span>。</p>
<h3 id="karp-rabin-algorithm">2.2 Karp-Rabin Algorithm</h3>
<p>用对比 hash value 代替直接对比字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ret, pos = false, -<span class="number">1</span></span><br><span class="line">hs = <span class="built_in">hash</span>(s)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(t)-<span class="built_in">len</span>(s)):</span><br><span class="line">  <span class="keyword">if</span> hs == <span class="built_in">hash</span>(t[i:i+<span class="built_in">len</span>(s)]):</span><br><span class="line">    <span class="keyword">if</span> s == t[i:i+<span class="built_in">len</span>(s)]:</span><br><span class="line">    	ret, pos = true, i</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">return</span> ret, pos</span><br></pre></td></tr></table></figure>
<p>时间复杂度：每次计算 hash value 消耗 <span class="math inline">\(\theta(|s|)\)</span>，如果 hash value 相等，需要再对比一次字符串，消耗 <span class="math inline">\(\theta(|s|)\)</span>。总体时间复杂度与 simple algorithm 相同，在常数项上有所差异。在计算 <code>hash(t[i:i+len(s)])</code> 时，我们已经见过了 <code>t[i:i+len(s)]</code> 中的所有字母，如果在计算 <code>hash(t[i+1:i+1+len(s)])</code> 时，我们可以只考虑 <code>t[i]</code> 和 <code>t[i+1+len(s)]</code>，那么时间复杂度降进一步降低。接下来看我们如何进一步将 <span class="math inline">\(|t| - |s|\)</span> 次 hash value 计算复杂度从 <span class="math inline">\(\theta(|s|)\)</span> 降低到 <span class="math inline">\(\theta(1)\)</span>。</p>
<h3 id="rolling-hash-adt">2.2.1 Rolling Hash ADT</h3>
<p>rolling hash ADT 维持一个字符串 <span class="math inline">\(s\)</span> 的信息，支持 3 种方法：</p>
<ul>
<li><code>r()</code>：获取当前字符串 <span class="math inline">\(s\)</span> 的 hash value，即 <span class="math inline">\(h(s)\)</span></li>
<li><code>r.append(c)</code>：往 <span class="math inline">\(s\)</span> 的末尾增加一个字符 <span class="math inline">\(c\)</span></li>
<li><code>r.skip(c)</code>：从 <span class="math inline">\(s\)</span> 的头部删除一个字符 <span class="math inline">\(c\)</span></li>
</ul>
<p>利用 rolling hash ADT，上面的 string matching 算法可以改写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">rs, rt = RollingHash(), RollingHash()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">  rs.append(c)</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> t[:<span class="built_in">len</span>(s)]:</span><br><span class="line">  rt.append(c)</span><br><span class="line"><span class="keyword">if</span> rs() == rt():</span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(s), <span class="built_in">len</span>(t)):</span><br><span class="line">  rt.skip(t[i-<span class="built_in">len</span>(s)])</span><br><span class="line">  rt.append(t[i])</span><br><span class="line">  <span class="keyword">if</span> rs() == rt():</span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>
<h3 id="rolling-hash-implementation">2.2.2 Rolling Hash Implementation</h3>
<p>将 <span class="math inline">\(s\)</span> 看作是基数 (base) 为 <span class="math inline">\(a\)</span> 的数字 <span class="math inline">\(u\)</span>，<span class="math inline">\(a\)</span> 为字符集大小。hash function 使用 division method： <span class="math display">\[
h(s) = u\space mod\space p
\]</span> 其中 <span class="math inline">\(p\)</span> 是与 <span class="math inline">\(|s|\)</span> 或 <span class="math inline">\(|t|\)</span> 接近的素数，那么：</p>
<ul>
<li><span class="math inline">\(r() = u\space mod\space p\)</span></li>
<li><span class="math inline">\(r.append(c): (u \cdot a + ord(c))\space mod\space p = [(u\space mod\space p)\cdot a + ord(c)]\space mod\space p\)</span></li>
<li><span class="math inline">\(r.skip(c): [u-ord(c)\cdot (a^{|s| - 1}\space mod \space p)]\space mod\space p \\= [(u\space mod\space p) - ord(c) \cdot (a^{|s|-1} mod \space p)] \space mod\space p\)</span></li>
</ul>
<p>rolling hash implementation 需要保存 <span class="math inline">\(u\space mod\space p\)</span> 和 <span class="math inline">\(|s|\)</span> 信息。</p>
<h3 id="complexity">2.2.3 Complexity</h3>
<p>利用 Karp-Rabin Algorithm，每次计算 hash value 的时间从 <span class="math inline">\(\theta(|s|)\)</span> 降低到 <span class="math inline">\(\theta(1)\)</span>，平均情况下时间复杂度为 <span class="math inline">\(\theta(|t|) + (1 + \#matches)\theta(|s|)\)</span>，即 <span class="math inline">\(O(|t| + |s|)\)</span>。最坏情况下时间复杂度仍为 <span class="math inline">\(O(|t|\cdot |s|)\)</span>，即每次 <span class="math inline">\(rs() == rt()\)</span>，触发字符串比较。</p>
<h2 id="references">References</h2>
<ul>
<li>MIT 6.006 lecture notes, <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec09_orig.pdf">handwritten</a>, <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/MIT6_006F11_lec09.pdf">notes typed</a>, <a target="_blank" rel="noopener" href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/lecture-videos/lecture-9-table-doubling-karp-rabin/">video</a></li>
<li>Wikipedia: <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm">Rabin-Karp algorithm</a></li>
<li>CLRS: 17.4</li>
</ul>

</div>


  <div class="book-comments">
    




  </div>



<script src="/opencourse-notes/js/book-post.js"></script>

        </div>
      </div>
      <div class="column col-2 hide-lg">
        <div class="book-post-info">
  
    <div class="book-post-meta">

  <div class="author">

    <!-- Author image -->
    <div class="author-img">
      
        <figure
          class="avatar avatar-lg"
          data-initial="郑"
          style="background-color: #3b4351;">
        </figure>
      
    </div>

    <!-- Author title -->
    <div class="author-title">
      <div>郑鹤</div>
      <div>2021-02-14</div>
    </div>
  </div>

  

  <div class="divider"></div>
</div>
  

  <div class="book-tocbot">
</div>
<div class="book-tocbot-menu">
  <a class="book-toc-expand" onclick="expand_toc()">Expand all</a>
  <a onclick="go_top()">Back to top</a>
  <a onclick="go_bottom()">Go to bottom</a>
</div>


<script src="/opencourse-notes/js/book-toc.js"></script>

</div>
      </div>
    </div>
  </div>
  
  <a class="off-canvas-overlay" onclick="hide_canvas()"></a>
</div>

</body>
</html>


<script src="/opencourse-notes/js/book.js"></script>
